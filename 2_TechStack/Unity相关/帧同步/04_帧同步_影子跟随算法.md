
https://skywind.me/blog/archives/1145

影子跟随算法由普通DR（dead reckoning）算法发展而来，我将其称为“影子跟随”意再表示算法同步策略的主要思想：

1． 屏幕上现实的实体（entity）只是不停的追逐它的“影子”（shadow）。
2． 服务器向各客户端发送各个影子的状态改变（坐标，方向，速度，时间）。
3． 各个客户端收到以后按照当前重新插值修正影子状态。
4． 影子状态是跳变的，但实体追赶影子是连续的，故整个过程是平滑的。



前面的1号终端控制红色飞船P1向左飞，并把自己的状态时时告诉服务器
后面的2号终端上接收到飞船P1的影子S1的状态（向左移动），并让P1的实体追赶S1
网络性能指标一：带宽，限制了实时游戏的人数容量
网络性能指标二：延时，决定了实时游戏的最低反应时间
使用该算法可以容易的开发出一款马里奥赛车，或者Counter Strike，详细说明见后：

##### 算法比较：

1． 帧间同步：不同客户端每帧显示相同的内容，键盘/时钟数据传到服务器，服务器确认后所有终端做出响应，多用于局域网游戏，比如红警（需要等待客户端），街霸II的网络版（360），网速要求高，复杂度低。参考以及 LockStep和TimeWrap算法，以及我2007年旧文 [帧锁定算法](http://www.skywind.me/blog/archives/131)。
2． 插值同步：不同客户端显示不同步，但是状态同步，常见的Dead Reckoning（或叫导航插值），效果好，但复杂度高。常见于竞速类游戏和 FPS游戏。

**算法定义**

1. 时间  ： 自己定义(如 FPS = 10) ，由服务器告诉所有的客户端
2. 客户端 ： 将每一帧自己的状态告诉服务器
3. 状态 ： 状态数据 = ID + 坐标 + 方向 + 速度 + 时间(帧) 
4. 插值 ： 收到新的状态包后根据其运动方向和事件，计算当前的新状态
5. 跟随 ： 实体不停的追踪自己的影子，追上后和影子保持同步

(可选) 
- 相位滞后
	- 实体和影子始终保持一定的同步距离，此时如果控制者**突然停止**， 就不需要跑过头再拉回来！！
- 惯性移动
	- 开始、停驶、改变方向都有加速度，这样就不需要滞后了。


每次服务器向各个客户端同步时间的时候，由于延迟，所有客户端的时间都是慢于服务器的，这没有关系，只要大家在一定误差范围内以相同的速度增加，就完全没有问题。


### 一些案例
#### CS

- **在开始移动和停止的时候加上惯性** -- 也就是 ： 存在0.5-1s的加速/减速过程。这样就不需要相位滞后造成的来回拉扯。
- 同时开枪射击采用客户端判断，也就是说如果我看见你在墙前面，开枪射中，那么我向服务器发送“我击中你了”，这时有可能真实的你在墙后，那么表现出来的就是我看见我打中你了（减不减血由服务段判断），而你没有看见我，觉得我穿墙打中你了。
- **关键状态缓存**：不然如果别人向前连续跳五次，每次取得状态都取到最高点的话，别人客户端上的影子和跟随的实体会奇怪的持续的飞在天上，所以需要将起跳和落地这两个关键状态缓存，实体追赶时只有追上的第一个状态（一号影子）才能追逐第二个状态（二号影子）。
- 由此可以在完全时间同步的情况下平滑的跑动、跳跃，开枪射击采用客户端判断后手感得到提高，唯一需要担心的就是外挂，外挂多是实时游戏的代价，只能通过Cheating Death等工具防止了。

#### 马车

影子和实体都使用惯性。

玩家碰到道具后，马上在屏幕上隐藏该道具的显示并通知服务器，由服务器决断道具属谁，由于刚碰到道具就隐藏所以不会有碰到道具却在一段时间内无法取得延迟现象。

游戏道具系统实现也很容易，比如那个将当前第一名炸毁的道具，它的描述是：原角色+对象角色+约定发生时间。既然知道对象是谁，什么时间发生，那就更本不需要怎么同步了，所有客户端和服务器在该时间让炸弹爆炸就得了，这种手法类似即时战略游戏。

游戏还有一类道具是可以发射的乌龟壳，这个东西属于有弹道的发射物，类似Quake里面的某些武器，需要作一些同步处理，基本特性是服务器判断起决定作用，客户端同步判断，如果客户端与服务器都判断集中，那就集中；如果客户端判断集中而服务器判断没有集中，那会看到该角色似乎被打了一下，但很快又恢复了速度向前冲。


